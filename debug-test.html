<!DOCTYPE html>
<html>
<head>
    <title>Debug Token Optimizer Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        .test-case {
            background: white;
            border: 2px solid #dc2626;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        .step {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
            font-size: 13px;
        }
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 15px 0;
        }
        .expected, .actual {
            padding: 12px;
            border-radius: 6px;
            font-family: ui-monospace, SFMono-Regular, monospace;
            font-size: 13px;
            white-space: pre-wrap;
        }
        .expected {
            background: #f0f9ff;
            border: 1px solid #bfdbfe;
        }
        .actual {
            background: #f0fdf4;
            border: 1px solid #bbf7d0;
        }
        .actual.fail {
            background: #fef2f2;
            border: 1px solid #fecaca;
        }
        button {
            background: #dc2626;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            margin: 10px 5px 0 0;
        }
        .pass { color: #16a34a; font-weight: bold; }
        .fail { color: #dc2626; font-weight: bold; }
    </style>
</head>
<body>
    <h1>üêõ Debug Token Optimizer - Step by Step Analysis</h1>
    
    <div id="test-results"></div>

    <script>
        // Test cases with expected results
        const testCases = [
            {
                name: "Basic Verbose Phrases",
                input: "I would like you to please help me understand due to the fact that at this point in time I need assistance with this problem",
                expected: "Help me understand because now I need assistance with this problem"
            },
            {
                name: "Word Duplication Matrix",
                input: "I really really need you to to help me me understand this this very very complex complex problem that that needs needs attention attention",
                expected: "I need you to help me understand this complex problem that needs attention"
            },
            {
                name: "Grammar Preservation",
                input: "could you to to help me understand this and please please make sure it's clear",
                expected: "Help me understand this and make sure it's clear"
            },
            {
                name: "Multi-Task Decomposition", 
                input: "I need you to help me write a business plan and also create a marketing strategy and then develop a budget forecast for my startup",
                expected: "1. Help me write a business plan\n2. Create a marketing strategy\n3. Develop a budget forecast for my startup"
            }
        ];

        // RECREATE THE OPTIMIZATION FUNCTIONS WITH DETAILED DEBUGGING
        function debugOptimization(text) {
            console.log('üî¨ Starting debug optimization...');
            console.log('üìù Input:', text);
            
            let optimized = text.trim();
            const steps = [];
            
            // STEP 1: Request Pattern Removal
            steps.push({ name: 'Original', text: optimized });
            
            const requestResult = debugRequestPatternRemoval(optimized);
            if (requestResult.changed) {
                optimized = requestResult.text;
                steps.push({ name: 'After Request Pattern Removal', text: optimized, changes: requestResult.changes });
            }
            
            // STEP 2: Duplicate Word Removal
            const duplicateResult = debugDuplicateRemoval(optimized);
            if (duplicateResult.changed) {
                optimized = duplicateResult.text;
                steps.push({ name: 'After Duplicate Removal', text: optimized, changes: duplicateResult.changes });
            }
            
            // STEP 3: Phrase Replacement
            const phraseResult = debugPhraseReplacement(optimized);
            if (phraseResult.changed) {
                optimized = phraseResult.text;
                steps.push({ name: 'After Phrase Replacement', text: optimized, changes: phraseResult.changes });
            }
            
            // STEP 4: Filler Word Removal
            const fillerResult = debugFillerRemoval(optimized);
            if (fillerResult.changed) {
                optimized = fillerResult.text;
                steps.push({ name: 'After Filler Removal', text: optimized, changes: fillerResult.changes });
            }
            
            // STEP 5: Task Chunking
            const chunkingResult = debugTaskChunking(optimized);
            if (chunkingResult.changed) {
                optimized = chunkingResult.text;
                steps.push({ name: 'After Task Chunking', text: optimized, changes: chunkingResult.changes });
            }
            
            // STEP 6: Final Cleanup
            const finalResult = debugFinalCleanup(optimized);
            optimized = finalResult;
            steps.push({ name: 'After Final Cleanup', text: optimized });
            
            console.log('‚úÖ Final result:', optimized);
            
            return { text: optimized, steps: steps };
        }

        function debugRequestPatternRemoval(text) {
            let result = text;
            const changes = [];
            let hasChanges = false;
            
            const patterns = [
                { pattern: /^i would really like you to please help me\s*/gi, replacement: 'Help me ', desc: 'Complex request opener' },
                { pattern: /^i would like you to please help me\s*/gi, replacement: 'Help me ', desc: 'Polite request opener' },
                { pattern: /^could you please help me\s*/gi, replacement: 'Help me ', desc: 'Modal request opener' },
                { pattern: /^can you please help me\s*/gi, replacement: 'Help me ', desc: 'Modal request opener' },
                { pattern: /^i would like you to please\s*/gi, replacement: '', desc: 'Request opener' },
                { pattern: /^could you please\s*/gi, replacement: '', desc: 'Modal request opener' },
                { pattern: /^would you please\s*/gi, replacement: '', desc: 'Modal request opener' },
                { pattern: /^can you please\s*/gi, replacement: '', desc: 'Modal request opener' },
                { pattern: /^i would like you to\s*/gi, replacement: '', desc: 'Request opener' },
                { pattern: /^i need you to\s*/gi, replacement: '', desc: 'Request opener' },
                { pattern: /^could you\s*/gi, replacement: '', desc: 'Simple request opener' },
                { pattern: /^can you\s*/gi, replacement: '', desc: 'Simple request opener' },
                { pattern: /^would you\s*/gi, replacement: '', desc: 'Simple request opener' },
                
                // Mid-sentence patterns
                { pattern: /\s+and\s+could you please/gi, replacement: ' and', desc: 'Mid-sentence request' },
                { pattern: /\s+also\s+could you please/gi, replacement: ' also', desc: 'Mid-sentence request' },
                { pattern: /\s+could you please/gi, replacement: '', desc: 'Mid-sentence request' }
            ];
            
            patterns.forEach(({ pattern, replacement, desc }) => {
                if (pattern.test(result)) {
                    console.log(`üîç Matched pattern: ${pattern} in "${result}"`);
                    result = result.replace(pattern, replacement);
                    changes.push({ pattern: pattern.toString(), replacement, desc });
                    hasChanges = true;
                    console.log(`‚û°Ô∏è After replacement: "${result}"`);
                }
            });
            
            return { text: result, changed: hasChanges, changes };
        }

        function debugDuplicateRemoval(text) {
            let result = text;
            const changes = [];
            let hasChanges = false;
            
            // Look for duplicates
            const duplicatePattern = /\b(\w+)\s+\1\b/gi;
            let matches = [...result.matchAll(duplicatePattern)];
            
            while (matches.length > 0) {
                console.log(`üîç Found duplicates:`, matches.map(m => m[0]));
                matches.forEach(match => {
                    changes.push({ 
                        type: 'remove', 
                        text: match[0], 
                        reason: `Duplicate: "${match[1]} ${match[1]}" ‚Üí "${match[1]}"` 
                    });
                });
                result = result.replace(duplicatePattern, '$1');
                hasChanges = true;
                console.log(`‚û°Ô∏è After duplicate removal: "${result}"`);
                
                // Check for more duplicates
                matches = [...result.matchAll(duplicatePattern)];
            }
            
            return { text: result, changed: hasChanges, changes };
        }

        function debugPhraseReplacement(text) {
            let result = text;
            const changes = [];
            let hasChanges = false;
            
            const phrases = [
                { pattern: /\bat this point in time\b/gi, replacement: 'now', desc: '"at this point in time" ‚Üí "now"' },
                { pattern: /\bdue to the fact that\b/gi, replacement: 'because', desc: '"due to the fact that" ‚Üí "because"' },
                { pattern: /\bit should be noted that\b/gi, replacement: '', desc: 'Meta-commentary removal' },
                { pattern: /\bas you can see\b/gi, replacement: '', desc: 'Meta-reference removal' },
                { pattern: /\bi think\b/gi, replacement: '', desc: 'Opinion marker removal' },
                { pattern: /\bi believe\b/gi, replacement: '', desc: 'Opinion marker removal' },
                { pattern: /\bwith regard to\b/gi, replacement: 'regarding', desc: '"with regard to" ‚Üí "regarding"' },
                { pattern: /\bin order to\b/gi, replacement: 'to', desc: '"in order to" ‚Üí "to"' },
                { pattern: /\bfor the purpose of\b/gi, replacement: 'for', desc: '"for the purpose of" ‚Üí "for"' }
            ];
            
            phrases.forEach(({ pattern, replacement, desc }) => {
                if (pattern.test(result)) {
                    console.log(`üîç Matched phrase: ${pattern} in "${result}"`);
                    result = result.replace(pattern, replacement);
                    changes.push({ pattern: pattern.toString(), replacement, desc });
                    hasChanges = true;
                    console.log(`‚û°Ô∏è After phrase replacement: "${result}"`);
                }
            });
            
            return { text: result, changed: hasChanges, changes };
        }

        function debugFillerRemoval(text) {
            let result = text;
            const changes = [];
            let hasChanges = false;
            
            const fillers = [
                'basically', 'obviously', 'clearly', 'essentially', 'ultimately',
                'literally', 'actually', 'really', 'very', 'quite', 'just', 'simply'
            ];
            
            fillers.forEach(filler => {
                const pattern = new RegExp(`\\b${filler}\\b\\s*`, 'gi');
                if (pattern.test(result)) {
                    console.log(`üîç Found filler: "${filler}" in "${result}"`);
                    result = result.replace(pattern, '');
                    changes.push({ filler, desc: `Filler word: "${filler}"` });
                    hasChanges = true;
                    console.log(`‚û°Ô∏è After filler removal: "${result}"`);
                }
            });
            
            return { text: result, changed: hasChanges, changes };
        }

        function debugTaskChunking(text) {
            if (text.length < 60) {
                return { text, changed: false, changes: [] };
            }
            
            const taskConnectors = /\s+(and also|also|and then|then|additionally|furthermore|moreover|finally|lastly)\s+/gi;
            
            if (!taskConnectors.test(text)) {
                return { text, changed: false, changes: [] };
            }
            
            console.log(`üîç Found task connectors in: "${text}"`);
            
            const parts = text.split(taskConnectors);
            console.log(`üîç Split into parts:`, parts);
            
            const cleanTasks = [];
            for (let i = 0; i < parts.length; i += 2) {
                const part = parts[i];
                if (part && part.trim().length > 15) {
                    let cleanTask = part.trim()
                        .replace(/^[,.\s]+/, '')
                        .replace(/\s+/g, ' ');
                    cleanTasks.push(cleanTask);
                }
            }
            
            console.log(`üîç Clean tasks:`, cleanTasks);
            
            if (cleanTasks.length >= 2 && cleanTasks.length <= 5) {
                const numberedTasks = cleanTasks
                    .map((task, index) => `${index + 1}. ${task}`)
                    .join('\n');
                
                console.log(`‚û°Ô∏è Numbered tasks: "${numberedTasks}"`);
                
                return { 
                    text: numberedTasks, 
                    changed: true, 
                    changes: [{ type: 'restructure', reason: 'Multi-task chunking with line breaks' }]
                };
            }
            
            return { text, changed: false, changes: [] };
        }

        function debugFinalCleanup(text) {
            let result = text
                .replace(/\s+/g, ' ')
                .replace(/\s*([,.!?;:])/g, '$1')
                .replace(/([,.!?;:])\s*([,.!?;:])/g, '$1')
                .replace(/^\s*[,.\s]+/, '')
                .replace(/\s*$/, '')
                .trim();
            
            if (result && /^[a-z]/.test(result)) {
                result = result.charAt(0).toUpperCase() + result.slice(1);
            }
            
            result = result
                .replace(/\s+to\s+to\s+/gi, ' to ')
                .replace(/\s+and\s+and\s+/gi, ' and ')
                .replace(/\s+with\s+with\s+/gi, ' with ')
                .replace(/\s{2,}/g, ' ');
            
            console.log(`‚û°Ô∏è Final cleanup: "${result}"`);
            
            return result;
        }

        function normalizeText(text) {
            return text.toLowerCase()
                .replace(/\s+/g, ' ')
                .replace(/[.,!?;:]/g, '')
                .trim();
        }

        function compareTexts(actual, expected) {
            const normalizedActual = normalizeText(actual);
            const normalizedExpected = normalizeText(expected);
            
            // For multi-line expected results, check structure
            if (expected.includes('\n')) {
                const expectedLines = expected.split('\n').map(normalizeText);
                const actualLines = actual.split('\n').map(normalizeText);
                
                if (expectedLines.length !== actualLines.length) {
                    return { pass: false, reason: `Line count mismatch: expected ${expectedLines.length}, got ${actualLines.length}` };
                }
                
                for (let i = 0; i < expectedLines.length; i++) {
                    const expectedLine = expectedLines[i].replace(/^\d+\.\s*/, '');
                    const actualLine = actualLines[i].replace(/^\d+\.\s*/, '');
                    
                    if (!actualLine.includes(expectedLine) && !expectedLine.includes(actualLine)) {
                        return { pass: false, reason: `Line ${i+1} mismatch: expected "${expectedLine}", got "${actualLine}"` };
                    }
                }
                return { pass: true };
            }
            
            // Simple text comparison
            if (normalizedActual.includes(normalizedExpected) || normalizedExpected.includes(normalizedActual)) {
                return { pass: true };
            }
            
            return { pass: false, reason: `Text mismatch: expected "${normalizedExpected}", got "${normalizedActual}"` };
        }

        function runDebugTests() {
            const container = document.getElementById('test-results');
            container.innerHTML = '';
            
            testCases.forEach((testCase, index) => {
                console.log(`\nüß™ Running debug test ${index + 1}: ${testCase.name}`);
                console.log(`üìù Input: "${testCase.input}"`);
                console.log(`üéØ Expected: "${testCase.expected}"`);
                
                const result = debugOptimization(testCase.input);
                const comparison = compareTexts(result.text, testCase.expected);
                
                const testDiv = document.createElement('div');
                testDiv.className = 'test-case';
                
                const stepsHtml = result.steps.map(step => `
                    <div class="step">
                        <strong>${step.name}:</strong><br>
                        <code>"${step.text}"</code>
                        ${step.changes ? `<br><small>Changes: ${step.changes.map(c => c.desc || c.reason).join(', ')}</small>` : ''}
                    </div>
                `).join('');
                
                testDiv.innerHTML = `
                    <h3>${comparison.pass ? '‚úÖ' : '‚ùå'} Test ${index + 1}: ${testCase.name} <span class="${comparison.pass ? 'pass' : 'fail'}">${comparison.pass ? 'PASS' : 'FAIL'}</span></h3>
                    
                    <div class="comparison">
                        <div class="expected">
                            <strong>Expected:</strong><br>
                            ${testCase.expected}
                        </div>
                        <div class="actual ${comparison.pass ? '' : 'fail'}">
                            <strong>Actual:</strong><br>
                            ${result.text}
                        </div>
                    </div>
                    
                    ${!comparison.pass ? `<div style="color: #dc2626; background: #fef2f2; padding: 10px; border-radius: 6px; margin: 10px 0;"><strong>‚ùå Failure Reason:</strong> ${comparison.reason}</div>` : ''}
                    
                    <details>
                        <summary><strong>Step-by-Step Processing</strong></summary>
                        ${stepsHtml}
                    </details>
                `;
                
                container.appendChild(testDiv);
            });
        }

        // Auto-run tests when page loads
        setTimeout(() => {
            console.log('üêõ Starting debug analysis...');
            runDebugTests();
        }, 1000);
    </script>
</body>
</html>